# -*- coding: utf-8 -*-
"""Untitled2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1rt-6Xw02Ly8acqwpwGfpvW2UqjC9RnBL
"""

!pip install -q transformers qwen-vl-utils==0.0.2

import os
import gdown
import torch
from transformers import Qwen2VLForConditionalGeneration, AutoProcessor
from qwen_vl_utils import process_vision_info
from PIL import Image
import matplotlib.pyplot as plt
import pandas as pd
import base64
from io import BytesIO

# Define the Google Drive folder ID and local download directory
GDRIVE_FOLDER_ID = "1hMZyonEVLLRDHOy4lnGQFgB5EuL3pnxq"
DOWNLOAD_DIR = "downloaded_images"

# Ensure the download directory exists
os.makedirs(DOWNLOAD_DIR, exist_ok=True)

# 1. Load the model and processor
model = Qwen2VLForConditionalGeneration.from_pretrained(
    "prithivMLmods/JSONify-Flux",
    torch_dtype="auto",
    device_map="auto"
)
processor = AutoProcessor.from_pretrained("prithivMLmods/Caption-Pro")

def download_images():
    """Download images from a Google Drive folder using gdown."""
    print("Downloading images from Google Drive...")
    gdown.download_folder(id=GDRIVE_FOLDER_ID, output=DOWNLOAD_DIR, quiet=False)

def encode_image_to_base64(image):
    """Encode a PIL image to base64 (for storing directly in a Parquet file)."""
    buffered = BytesIO()
    image.save(buffered, format="JPEG")
    return base64.b64encode(buffered.getvalue()).decode('utf-8')

def process_and_display_images():
    data = []

    # 2. Loop through downloaded images
    for filename in os.listdir(DOWNLOAD_DIR):
        image_path = os.path.join(DOWNLOAD_DIR, filename)
        if not filename.lower().endswith((".jpg", ".jpeg", ".png")):
            continue

        try:
            # 2a. Open the image with PIL
            image = Image.open(image_path).convert("RGB")

            # 2b. Create the messages with the *actual* image
            #    (Minimal textual instruction, but you can customize.)
            messages = [
                {
                    "role": "user",
                    "content": [
                        {"type": "image", "image": image},
                        {"type": "text", "text": "Generate a detailed and optimized caption for the given image."},
                    ],
                }
            ]

            # 3. Prepare the inputs for Qwen-VL
            text = processor.apply_chat_template(
                messages, tokenize=False, add_generation_prompt=True
            )
            image_inputs, video_inputs = process_vision_info(messages)
            inputs = processor(
                text=[text],
                images=image_inputs,
                videos=video_inputs,
                padding=True,
                return_tensors="pt",
            )
            inputs = inputs.to("cuda" if torch.cuda.is_available() else "cpu")

            # 4. Generate the caption
            generated_ids = model.generate(**inputs, max_new_tokens=128)
            # Remove the portion of the output that duplicates input tokens
            generated_ids_trimmed = [
                out_ids[len(in_ids):]
                for in_ids, out_ids in zip(inputs.input_ids, generated_ids)
            ]
            output_text = processor.batch_decode(
                generated_ids_trimmed,
                skip_special_tokens=True,
                clean_up_tokenization_spaces=False,
            )[0]

            # 5. Show the image + caption
            plt.figure()
            plt.imshow(image)
            plt.axis("off")
            plt.figtext(
                0.5, 0.01,
                f"Caption: {output_text}",
                wrap=True,
                horizontalalignment='center',
                fontsize=12,
                color='black'
            )
            plt.show()

            # 6. Store results (image in base64 + generated caption)
            image_base64 = encode_image_to_base64(image)
            data.append({"image": image_base64, "caption": output_text})

        except Exception as e:
            print(f"Error processing {filename}: {e}")

    # 7. Convert the list of dicts to a DataFrame and save as Parquet
    df = pd.DataFrame(data)
    df.to_parquet("image_captions_dataset.parquet", index=False)
    print("Dataset saved as image_captions_dataset.parquet")

# Run the pipeline
download_images()
process_and_display_images()